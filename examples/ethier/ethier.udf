//
// nekRS User Defined File
//

#include <math.h>
#include "udf.hpp"

#include "ci.inc"
#include <vector>
#include "randomVector.hpp"

static lpm_t *particles;

static dfloat P_U0;
static dfloat P_V0;
static dfloat P_W0;

static dfloat P_A0;
static dfloat P_D0;

static dfloat P_OMEGA;
static dfloat P_AMP;

occa::memory o_x0, o_y0, o_z0;

@oklBegin
{

  @kernel void dpdx(const dlong Ntotal,
                    const dfloat time,
                    @ restrict const dfloat *x,
                    @ restrict const dfloat *y,
                    @ restrict const dfloat *z,
                    const dlong offset,
                    @ restrict dfloat *FS)
  {
    for (dlong n = 0; n < Ntotal; ++n; @tile(p_blockSize, @outer, @inner)) {
      if (n < Ntotal) {
        const dfloat xn = x[n];
        const dfloat yn = y[n];
        const dfloat zn = z[n];
        //
        const dfloat a = p_A;
        const dfloat d = p_D;
        //
        const dfloat xx = xn - p_U0 * time;
        const dfloat yy = yn - p_V0 * time;
        const dfloat zz = zn - p_W0 * time;
        //
        const dfloat exy = exp(a * (xx + yy));
        const dfloat eyz = exp(a * (yy + zz));
        const dfloat ezx = exp(a * (zz + xx));
        //
        const dfloat sxy = sin(a * xx + d * yy);
        const dfloat syz = sin(a * yy + d * zz);
        const dfloat szx = sin(a * zz + d * xx);
        //
        const dfloat cxy = cos(a * xx + d * yy);
        const dfloat cyz = cos(a * yy + d * zz);
        const dfloat czx = cos(a * zz + d * xx);
        //
        const dfloat dpdx =
            -0.5f * (a * a * exp(-2.f * d * d * p_nu * time) *
                     (2.f * a * exp(2.f * a * xx) + 2.f * a * cxy * czx * eyz + 2.f * d * czx * cyz * exy +
                      2.f * a * cxy * syz * ezx + 2.f * a * cyz * szx * exy - 2.f * a * sxy * syz * ezx -
                      2.f * d * sxy * szx * eyz));

        FS[n + offset] = -dpdx;
      }
    }
  }

  void exact(dfloat * u,
             dfloat * v,
             dfloat * w,
             dfloat * p,
             const dfloat x,
             const dfloat y,
             const dfloat z,
             const dfloat t,
             const dfloat visc)
  {
    const dfloat a = p_A;
    const dfloat d = p_D;

    const dfloat xx = x - p_U0 * t;
    const dfloat yy = y - p_V0 * t;
    const dfloat zz = z - p_W0 * t;

    const dfloat ex = exp(a * xx);
    const dfloat ey = exp(a * yy);
    const dfloat ez = exp(a * zz);
    const dfloat e2t = exp(-visc * d * d * t);

    const dfloat exy = exp(a * (xx + yy));
    const dfloat eyz = exp(a * (yy + zz));
    const dfloat ezx = exp(a * (zz + xx));

    const dfloat sxy = sin(a * xx + d * yy);
    const dfloat syz = sin(a * yy + d * zz);
    const dfloat szx = sin(a * zz + d * xx);

    const dfloat cxy = cos(a * xx + d * yy);
    const dfloat cyz = cos(a * yy + d * zz);
    const dfloat czx = cos(a * zz + d * xx);

    *(u) = -a * (ex * syz + ez * cxy) * e2t + p_U0;
    *(v) = -a * (ey * szx + ex * cyz) * e2t + p_V0;
    *(w) = -a * (ez * sxy + ey * czx) * e2t + p_W0;

    *(p) =
        0.5 * a * a * e2t * e2t *
        (ex * ex + 2.0 * sxy * czx * eyz + ey * ey + 2.0 * syz * cxy * ezx + ez * ez + 2.0 * szx * cyz * exy);
  }

  void grad_u(dfloat * grad_u_x,
              dfloat * grad_u_y,
              dfloat * grad_u_z,
              const dfloat x,
              const dfloat y,
              const dfloat z,
              const dfloat t,
              const dfloat visc)
  {
    const dfloat a = p_A;
    const dfloat d = p_D;

    const dfloat xx = x - p_U0 * t;
    const dfloat yy = y - p_V0 * t;
    const dfloat zz = z - p_W0 * t;

    const dfloat ex = exp(a * xx);
    const dfloat ey = exp(a * yy);
    const dfloat ez = exp(a * zz);
    const dfloat e2t = exp(-visc * d * d * t);

    const dfloat exy = exp(a * (xx + yy));
    const dfloat eyz = exp(a * (yy + zz));
    const dfloat ezx = exp(a * (zz + xx));

    const dfloat sxy = sin(a * xx + d * yy);
    const dfloat syz = sin(a * yy + d * zz);
    const dfloat szx = sin(a * zz + d * xx);

    const dfloat cxy = cos(a * xx + d * yy);
    const dfloat cyz = cos(a * yy + d * zz);
    const dfloat czx = cos(a * zz + d * xx);

    //*(u)= -a*(ex*syz + ez*cxy)*e2t;
    *(grad_u_x) = -a * ((a * ex) * syz - a * ez * sxy) * e2t;
    *(grad_u_y) = -a * (ex * (a * cyz) + ez * (-d * sxy)) * e2t;
    *(grad_u_z) = -a * (ex * (d * cyz) + (a * ez) * cxy) * e2t;
  }

  @kernel void exactUVWP(const dlong Ntotal,
                         const dfloat time,
                         @ restrict const dfloat *X,
                         @ restrict const dfloat *Y,
                         @ restrict const dfloat *Z,
                         const dlong offset,
                         @ restrict dfloat *P,
                         @ restrict dfloat *U)
  {
    for (dlong n = 0; n < Ntotal; ++n; @tile(p_blockSize, @outer, @inner)) {
      if (n < Ntotal) {
        dfloat u, v, w, p;
        const dfloat x = X[n];
        const dfloat y = Y[n];
        const dfloat z = Z[n];
        exact(&u, &v, &w, &p, x, y, z, time, p_nu);
        U[n + 0 * offset] = u;
        U[n + 1 * offset] = v;
        U[n + 2 * offset] = w;
        P[n] = p;
      }
    }
  }

  void velocityDirichletConditions(bcData * bc)
  {
    dfloat u, v, w, p;
    exact(&u, &v, &w, &p, bc->x, bc->y, bc->z, bc->time, p_nu);
    bc->u = u;
    bc->v = v;
    bc->w = w;
  }

  void scalarDirichletConditions(bcData * bc)
  {
    dfloat u, v, w, p;
    exact(&u, &v, &w, &p, bc->x, bc->y, bc->z, bc->time, p_nu);
    bc->s = u;
  }

  void scalarNeumannConditions(bcData * bc)
  {
    dfloat grad_u_x, grad_u_y, grad_u_z;
    grad_u(&grad_u_x, &grad_u_y, &grad_u_z, bc->x, bc->y, bc->z, bc->time, p_nu);
    bc->flux = p_nu * (grad_u_x * bc->nx + grad_u_y * bc->ny + grad_u_z * bc->nz);
  }

  @kernel void userMeshVelocity(const dlong Ntotal,
                                const dlong offset,
                                const dfloat time,
                                @ restrict const dfloat *x,
                                @ restrict const dfloat *y,
                                @ restrict const dfloat *z,
                                @ restrict dfloat *W)
  {
    for (dlong n = 0; n < Ntotal; ++n; @tile(p_blockSize, @outer, @inner)) {
      const dfloat ampx = p_amp * cos(p_omega * time);
      const dfloat ampy = p_amp * cos(0.5 * p_omega * time);
      const dfloat ampz = p_amp * cos(0.5 * 0.5 * p_omega * time);
      const dfloat xx = 0.5 * (x[n] + 1); // in [0 1]
      const dfloat yy = 0.5 * (y[n] + 1); // in [0 1]
      const dfloat zz = 0.5 * (z[n] + 1); // in [0 1]
      W[n + 0 * offset] = ampx * sin(p_pi * xx);
      W[n + 1 * offset] = ampy * sin(p_pi * yy);
      W[n + 2 * offset] = ampz * sin(p_pi * zz);
    }
  }

  // compute the right hand side of the particle drag equation
  @kernel void particleRHS(const dlong nParticles,
                           const dlong offset,
                           @ restrict const dfloat *y, // particle DOFS
                           @ restrict const dfloat *U, // interpolated fluid velocity
                           @ restrict dfloat *ydot)
  {
    for (dlong pid = 0; pid < nParticles; ++pid; @tile(p_blockSize, @outer, @inner)) {
      const dfloat u = U[pid + 0 * offset];
      const dfloat v = U[pid + 1 * offset];
      const dfloat w = U[pid + 2 * offset];

      // dx_i/dt = u
      ydot[pid + 0 * offset] = u;
      ydot[pid + 1 * offset] = v;
      ydot[pid + 2 * offset] = w;
    }
  }

  @kernel void RK(const dlong N,
                  const dfloat sdt,
                  @ restrict const dfloat *rkb,
                  @ restrict const dfloat *r1,
                  @ restrict const dfloat *r2,
                  @ restrict const dfloat *r3,
                  @ restrict const dfloat *r4,
                  @ restrict dfloat *y)
  {

    for (dlong n = 0; n < N; ++n; @tile(p_blockSize, @outer, @inner)) {
      dfloat sn = 0.0;
      sn += sdt * rkb[0] * r1[n];
      sn += sdt * rkb[1] * r2[n];
      sn += sdt * rkb[2] * r3[n];
      sn += sdt * rkb[3] * r4[n];
      y[n] += sn;
    }
  }
}
@oklEnd

// generate random coordinates within a sphere of radius R
auto
generateCoordinates(int n, double R)
{
  auto xp = randomVector<dfloat>(n);
  auto yp = randomVector<dfloat>(n);
  auto zp = randomVector<dfloat>(n);
  const auto third = 1.0 / 3.0;
  for (int pt = 0; pt < n; ++pt) {
    auto x = xp[pt];
    auto y = yp[pt];
    auto z = zp[pt];

    // map [0,1] to [-1,1]
    x = 2 * x - 1;
    y = 2 * y - 1;
    z = 2 * z - 1;

    // map unit-cube [-1,1]^3 to sphere
    // adapted from https://stackoverflow.com/questions/2656899
    const auto sx = x * std::sqrt(1.0 - 0.5 * y * y - 0.5 * z * z + third * y * y * z * z);
    const auto sy = y * std::sqrt(1.0 - 0.5 * z * z - 0.5 * x * x + third * z * z * x * x);
    const auto sz = z * std::sqrt(1.0 - 0.5 * x * x - 0.5 * y * y + third * x * x * y * y);

    // rescale to desired radius
    auto Rp = randomVector<dfloat>(1)[0] * R;
    const auto r = std::sqrt(sx * sx + sy * sy + sz * sz);
    const auto scale = Rp / r;
    xp[pt] = sx * scale;
    yp[pt] = sy * scale;
    zp[pt] = sz * scale;
  }
  return std::make_tuple(xp, yp, zp);
}

void userq(nrs_t *nrs, dfloat time, occa::memory o_S, occa::memory o_FS)
{
  mesh_t *mesh = nrs->meshV;
  cds_t *cds = nrs->cds;
  const dlong Nlocal = nrs->meshV->Nelements * nrs->meshV->Np;

  dpdxKernel(Nlocal, time, mesh->o_x, mesh->o_y, mesh->o_z, 0 * cds->fieldOffset[0], o_FS);
  dpdxKernel(Nlocal, time, mesh->o_x, mesh->o_y, mesh->o_z, 1 * cds->fieldOffset[0], o_FS);
}

void UDF_LoadKernels(occa::properties &kernelInfo)
{
  // called from all ranks, so MPI collectives are O.K.
  int maxRank = platform->comm.mpiRank;
  MPI_Allreduce(MPI_IN_PLACE, &maxRank, 1, MPI_INT, MPI_MAX, platform->comm.mpiComm);

  setupAide &options = platform->options;

  dfloat mue, rho;
  options.getArgs("VISCOSITY", mue);
  options.getArgs("DENSITY", rho);
  kernelInfo["defines/p_nu"] = mue / rho;
  kernelInfo["defines/p_U0"] = P_U0;
  kernelInfo["defines/p_V0"] = P_V0;
  kernelInfo["defines/p_W0"] = P_W0;
  kernelInfo["defines/p_A"] = P_A0 * M_PI;
  kernelInfo["defines/p_D"] = P_D0 * M_PI;
  kernelInfo["defines/p_amp"] = P_AMP;
  kernelInfo["defines/p_omega"] = P_OMEGA;
  kernelInfo["defines/p_pi"] = M_PI;

  // register kernel specific kernels
  lpm_t::registerKernels(kernelInfo);
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  options.getArgs("CI-MODE", ciMode);
  if (ciMode)
    ciSetup(comm, options);
  platform->par->extract("casedata", "p_u0", P_U0);
  platform->par->extract("casedata", "p_v0", P_V0);
  platform->par->extract("casedata", "p_w0", P_W0);
  platform->par->extract("casedata", "p_a0", P_A0);
  platform->par->extract("casedata", "p_d0", P_D0);
  platform->par->extract("casedata", "p_omega", P_OMEGA);
  platform->par->extract("casedata", "p_amp", P_AMP);

  if (platform->options.compareArgs("BUILD ONLY", "FALSE")) {
    double *const nek_cb_scnrs = (double *)nek::ptr("cb_scnrs");
    nek_cb_scnrs[0] = P_U0;
    nek_cb_scnrs[1] = P_V0;
    nek_cb_scnrs[2] = P_W0;
    nek_cb_scnrs[3] = P_A0;
    nek_cb_scnrs[4] = P_D0;
    nek_cb_scnrs[5] = P_OMEGA;
    nek_cb_scnrs[6] = P_AMP;
  }
}

void particleRHS(nrs_t *nrs, lpm_t *lpm, dfloat time, occa::memory o_y, void *userdata, occa::memory o_ydot)
{
  auto offset = lpm->fieldOffset();

  // evaluate fluid fields at particle positions
  lpm->interpolate();

  auto o_Uinterp = lpm->getInterpField("fluid_velocity");

  particleRHSKernel(lpm->size(), offset, o_y, o_Uinterp, o_ydot);
}

void UDF_Setup(nrs_t *nrs)
{
  particles = new lpm_t(nrs, nrs->nEXT, 0.0);
  particles->setUserRHS(particleRHS);

  // register fluid velocity as an interpolated quantity
  particles->registerInterpField("fluid_velocity", nrs->NVfields, nrs->o_U);

  const int nPartGlobal = 1000;
  int nPartPerRank = nPartGlobal / platform->comm.mpiCommSize;

  const auto remainder = nPartGlobal % platform->comm.mpiCommSize;
  if(platform->comm.mpiRank < remainder)
    nPartPerRank++;

  const double R = 0.1;
  std::tie(xp0, yp0, zp0) = generateCoordinates(nPartPerRank, R);
  auto np = xp0.size();
  particles->construct(np);

  const auto particleOffset = particles->fieldOffset();
  std::vector y0(particles->nDOFs() * particleOffset, 0.0);
  for (int n = 0; n < np; ++n) {
    // first 3 components are always the particle position
    y0[n + 0 * particleOffset] = xp0[n];
    y0[n + 1 * particleOffset] = yp0[n];
    y0[n + 2 * particleOffset] = zp0[n];
  }

  // set initial particle positions
  particles->o_y.copyFrom(y0.data(), particles->nDOFs() * particleOffset * sizeof(dfloat));

  mesh_t *mesh = nrs->meshV;
  udf.sEqnSource = &userq;
  if (platform->options.compareArgs("MOVING MESH", std::string("TRUE"))) {
    o_x0 = platform->device.malloc(mesh->Nlocal, sizeof(dfloat), mesh->o_x);
    o_y0 = platform->device.malloc(mesh->Nlocal, sizeof(dfloat), mesh->o_y);
    o_z0 = platform->device.malloc(mesh->Nlocal, sizeof(dfloat), mesh->o_z);
  }
}

void addParticles()
{
  // Add new particles randomly distributed in the domain
  constexpr int nNewParticles = 100;
  double R = 0.95;
  auto [xp, yp, zp] = generateCoordinates(nNewParticles, R);

  auto inputOffset = lpm_t::fieldOffset(nNewParticles);
  auto o_yNew = platform->device.malloc(particles->nDOFs() * inputOffset * sizeof(dfloat));

  auto o_xCoordNew = o_yNew + 0 * inputOffset * sizeof(dfloat);
  auto o_yCoordNew = o_yNew + 1 * inputOffset * sizeof(dfloat);
  auto o_zCoordNew = o_yNew + 2 * inputOffset * sizeof(dfloat);
  o_xCoordNew.copyFrom(xp.data(), nNewParticles * sizeof(dfloat));
  o_yCoordNew.copyFrom(yp.data(), nNewParticles * sizeof(dfloat));
  o_zCoordNew.copyFrom(zp.data(), nNewParticles * sizeof(dfloat));

  // there are no register properties -- just pass a null pointer
  occa::memory o_nullProps;

  particles->addParticles(nNewParticles, o_yNew, o_nullProps);

  o_yNew.free();
}

void setParticleSolution(nrs_t *nrs, dfloat time)
{
  auto o_y0 = platform->device.malloc(nrs->dim * xp0.size() * sizeof(dfloat));
  auto o_x0coord = o_y0 + 0 * xp0.size() * sizeof(dfloat);
  auto o_y0coord = o_y0 + 1 * yp0.size() * sizeof(dfloat);
  auto o_z0coord = o_y0 + 2 * zp0.size() * sizeof(dfloat);
  o_x0coord.copyFrom(xp0.data(), xp0.size() * sizeof(dfloat));
  o_y0coord.copyFrom(yp0.data(), yp0.size() * sizeof(dfloat));
  o_z0coord.copyFrom(zp0.data(), zp0.size() * sizeof(dfloat));

  auto o_y = solveODE(nrs, 0.0, time, 1e-3 * nrs->dt[0], o_y0, exactUVWPKernel, RKKernel);

  auto o_xcoord = o_y + 0 * xp0.size() * sizeof(dfloat);
  auto o_ycoord = o_y + 1 * xp0.size() * sizeof(dfloat);
  auto o_zcoord = o_y + 2 * xp0.size() * sizeof(dfloat);

  auto o_xp = particles->o_y + 0 * particles->fieldOffset() * sizeof(dfloat);
  auto o_yp = particles->o_y + 1 * particles->fieldOffset() * sizeof(dfloat);
  auto o_zp = particles->o_y + 2 * particles->fieldOffset() * sizeof(dfloat);

  o_xp.copyFrom(o_xcoord, xp0.size() * sizeof(dfloat));
  o_yp.copyFrom(o_ycoord, yp0.size() * sizeof(dfloat));
  o_zp.copyFrom(o_zcoord, zp0.size() * sizeof(dfloat));
}

void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{

  mesh_t *mesh = nrs->meshV;
  cds_t *cds = nrs->cds;

  if (tstep <= 5) {
    exactUVWPKernel(mesh->Nlocal,
                    time,
                    mesh->o_x,
                    mesh->o_y,
                    mesh->o_z,
                    nrs->fieldOffset,
                    nrs->o_P,
                    nrs->o_U);
    if (nrs->pSolver)
      ellipticZeroMean(nrs->pSolver, nrs->o_P);
    if (nrs->Nscalar > 0)
      cds->o_S.copyFrom(nrs->o_U, mesh->Nlocal * sizeof(dfloat), 0 * cds->fieldOffset[0] * sizeof(dfloat));
    if (nrs->Nscalar > 1)
      cds->o_S.copyFrom(nrs->o_U, mesh->Nlocal * sizeof(dfloat), 1 * cds->fieldOffset[0] * sizeof(dfloat));

    setParticleSolution(nrs, time);
  }

  if (platform->options.compareArgs("MOVING MESH", std::string("TRUE")))
    userMeshVelocityKernel(mesh->Nlocal, nrs->fieldOffset, time, o_x0, o_y0, o_z0, mesh->o_U);

  if (!nrs->lastStep) {
    particles->integrate(time, time + nrs->dt[0], tstep);
  }

  if (nrs->isOutputStep) {
    nek::ocopyToNek(time, tstep);
    nek::userchk();

    particles->writeFld(time);
    if (!ciMode) {
      addParticles();
    }
  }

  if (ciMode) {
    ciTestErrors(nrs, time, tstep, *particles, exactUVWPKernel, RKKernel);
  }
}
