//
// nekRS User Defined File
//
#include <math.h>
#include "udf.hpp"
#include "randomVector.hpp"

static dfloat Stk;
static dlong nParticles;
static dlong nParticlesGlobal;
static occa::kernel particleRHSKernel;
static lpm_t* particles = nullptr;

/* UDF Functions */                                                      

void UDF_LoadKernels(occa::properties& kernelInfo)
{
  particleRHSKernel = oudfBuildKernel(kernelInfo, "particleRHS");
  lpm_t::registerKernels(kernelInfo);
}

void UDF_Setup0(MPI_Comm comm, setupAide &options)
{
  int commSize;
  MPI_Comm_size(comm, &commSize);

  int rank;
  MPI_Comm_rank(comm, &rank);

  platform->par->extract("casedata", "stk", Stk);
  platform->par->extract("casedata", "nparticles", nParticlesGlobal);

  nParticles = nParticlesGlobal / commSize;

  // distribute remaining particles
  const int remainder = nParticlesGlobal % commSize;
  if(rank < remainder)
    nParticles++;
}

void particleRHS(nrs_t *nrs, lpm_t *lpm, dfloat time, occa::memory o_y, void *userdata, occa::memory o_ydot)
{
  auto offset = lpm->fieldOffset();

  // evaluate fluid fields at particle positions
  lpm->interpolate();

  auto o_Uinterp = lpm->getInterpField("fluid_velocity");

  particleRHSKernel(lpm->size(), offset, o_y, lpm->o_prop, o_Uinterp, o_ydot);
}

void UDF_Setup(nrs_t *nrs)
{
  auto * mesh = nrs->meshV;

  particles = new lpm_t(nrs, 0.0);
  particles->setUserRHS(particleRHS);

  particles->setSolver("AB");
  const int particleIntegrationOrder = 3;
  particles->abOrder(particleIntegrationOrder);

  // register fluid velocity as an interpolated quantity
  particles->registerInterpField("fluid_velocity", nrs->NVfields, nrs->o_U);

  // register particle velocity as DOF
  particles->registerDOF(nrs->NVfields, "velocity");

  // register Stokes number as a property
  particles->registerProp("stokes_number");

  // generate random particles in the domain
  auto xPart = randomVector<dfloat>(nParticles);
  auto yPart = randomVector<dfloat>(nParticles);
  auto zPart = randomVector<dfloat>(nParticles);

  const auto xMin = platform->linAlg->min(mesh->Nlocal, mesh->o_x, platform->comm.mpiComm);
  const auto yMin = platform->linAlg->min(mesh->Nlocal, mesh->o_y, platform->comm.mpiComm);
  const auto zMin = platform->linAlg->min(mesh->Nlocal, mesh->o_z, platform->comm.mpiComm);

  const auto xMax = platform->linAlg->max(mesh->Nlocal, mesh->o_x, platform->comm.mpiComm);
  const auto yMax = platform->linAlg->max(mesh->Nlocal, mesh->o_y, platform->comm.mpiComm);
  const auto zMax = platform->linAlg->max(mesh->Nlocal, mesh->o_z, platform->comm.mpiComm);

  for(int pid = 0; pid < nParticles; ++pid){
    const auto x = xPart[pid];
    const auto y = yPart[pid];
    const auto z = zPart[pid];

    // particle initial coordinates
    xPart[pid] = xMin + (xMax - xMin)*x;
    yPart[pid] = yMin + (yMax - yMin)*y;
    zPart[pid] = zMin + (zMax - zMin)*z;
  }

  // interpolate initial fluid velocity onto particle positions
  std::vector<dfloat> particleU0(nrs->NVfields * nParticles);
  auto interpolator = pointInterpolation_t(nrs);
  interpolator.addPoints(nParticles, xPart.data(), yPart.data(), zPart.data());
  interpolator.find();

  interpolator.eval(nrs->NVfields, nrs->fieldOffset, nrs->U, nParticles, particleU0.data());

  // set particle initial positions and velocities
  std::vector<dfloat> y0(particles->nDOFs() * nParticles);

  for(int pid = 0; pid < nParticles; ++pid){
    const auto x = xPart[pid];
    const auto y = yPart[pid];
    const auto z = zPart[pid];

    const auto u = particleU0[pid + 0 * nParticles];
    const auto v = particleU0[pid + 1 * nParticles];
    const auto w = particleU0[pid + 2 * nParticles];

    y0[pid + 0 * nParticles] = x;
    y0[pid + 1 * nParticles] = y;
    y0[pid + 2 * nParticles] = z;

    y0[pid + 3 * nParticles] = u;
    y0[pid + 4 * nParticles] = v;
    y0[pid + 5 * nParticles] = w;
  }

  dfloat t0;
  platform->options.getArgs("START TIME", t0);
  particles->initialize(nParticles, t0, y0);

  // set Stokes number
  platform->linAlg->fill(nParticles, Stk, particles->o_prop);

}

void UDF_ExecuteStep(nrs_t *nrs, dfloat time, int tstep)
{
  if (!nrs->lastStep) {
    particles->integrate(time, time + nrs->dt[0], tstep);
  }

  if (nrs->isOutputStep) {
    nek::ocopyToNek(time, tstep);
    nek::userchk(); // compute lambda2
    nek::ocopyFromNek(time);

    particles->writeFld(time);
  }
}
