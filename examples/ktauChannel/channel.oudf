@kernel void dragScale(const dlong Nelements,
		       const dlong offset,
		       @restrict const dfloat *vgeo,
		       @restrict dfloat *drag)
{
  for (dlong e = 0; e < Nelements; ++e; @outer(0)) {
    for (int k = 0; k < p_Nq; ++k) {
      for (int j = 0; j < p_Nq; ++j; @inner(1)) {
	for (int i = 0; i < p_Nq; ++i; @inner(0)) {
	  const dlong id = e * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;
	  const dlong gid = e * p_Np * p_Nvgeo + k * p_Nq * p_Nq + j * p_Nq + i;

	  const dfloat JW = vgeo[gid + p_JWID * p_Np];
	  const dfloat invJ = 1./JW;

	  drag[id + 0 * offset] *= invJ;
	  drag[id + 1 * offset] *= invJ;
	  drag[id + 2 * offset] *= invJ;
	}
      }
    }
  }
}
@kernel void drag(const dlong Nelements,
		  const dlong offset,
		  const dfloat mue,
		  @ restrict const dfloat *sgeo,
		  @ restrict const dlong *vmapM,
		  @ restrict const int *EToB,
		  @ restrict const dfloat *sij,		  
		  @ restrict dfloat *drag)
{
  for (dlong e = 0; e < Nelements; e++; @outer(0)) {
    
    for (int f = 0; f < p_Nfaces; f++) {
      for (int m = 0; m < p_Nfp; ++m; @inner(0)) {
	const int n = m + f * p_Nfp;
        const int sk = e * p_Nfp * p_Nfaces + n;
	const dlong sid = e * p_Nfaces * p_Nfp + n;
	const dlong idM = vmapM[sk];
        const dlong bcType = EToB[f + p_Nfaces * e];

	const dfloat n1 = sgeo[sid * p_Nsgeo + p_NXID];
	const dfloat n2 = sgeo[sid * p_Nsgeo + p_NYID];
	const dfloat n3 = sgeo[sid * p_Nsgeo + p_NZID];
		
	if(bcType == p_bcTypeW){
	  const dfloat s11 = sij[idM + 0 * offset];
	  const dfloat s21 = sij[idM + 3 * offset];
	  const dfloat s31 = sij[idM + 5 * offset];

	  const dfloat s12 = sij[idM + 3 * offset];
	  const dfloat s22 = sij[idM + 1 * offset];
	  const dfloat s32 = sij[idM + 4 * offset];

	  const dfloat s13 = sij[idM + 5 * offset];
	  const dfloat s23 = sij[idM + 4 * offset];
	  const dfloat s33 = sij[idM + 2 * offset];

	  drag[idM + 0 * offset] = -mue * (s11*n1 + s12*n2 + s13*n3);
	  drag[idM + 1 * offset] = -mue * (s21*n1 + s22*n2 + s23*n3);
	  drag[idM + 2 * offset] = -mue * (s31*n1 + s32*n2 + s33*n3);
	}
      }
      @barrier();
    }
  }
}

@kernel void scalarScaledAdd(const dlong N,
                             const dfloat a,
                             const dfloat b,
                             @restrict const dfloat* X,
                             @restrict dfloat* Y)
{
  for(dlong n = 0; n < N; ++n; @tile(256,@outer,@inner))
    if(n < N)
      Y[n] = a + b * X[n];
}

void scalarDirichletConditions(bcData *bc)
{
  bc->s = 0;
  if(bc->scalarId == 0) bc->s = 0; 
}
