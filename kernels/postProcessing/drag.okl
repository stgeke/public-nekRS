
@kernel void drag(const dlong Nelements,
		  const dlong offset,
		  const dlong soffset,
		  const dlong nbiD,
		  const dfloat mue,
		  const dlong biD,
		  @ restrict const dfloat *sgeo,
		  @ restrict const dlong *vmapM,
		  @ restrict const int *EToBM,
		  @ restrict const dfloat *invLMM,
		  @ restrict const dfloat *sij,		  
		  @ restrict dfloat *drag,
		  @ restrict dfloat *area)
{
  for (dlong e = 0; e < Nelements; e++; @outer(0)) {

    @exclusive dfloat s_drag;
    @exclusive dfloat s_area;
    
    for (int f = 0; f < p_Nfaces; f++) {
      const dlong biDM = EToBM[f + p_Nfaces * e];
      for (int m = 0; m < p_Nfp; ++m; @inner(0)){
	s_drag = 0.0;
	s_area = 0.0;
	if(biDM == biD){
	  const int n = m + f * p_Nfp;
	  const dlong sid = e * p_Nfaces * p_Nfp + n;
	  
	  const dlong idM = vmapM[sid];
	  const dfloat sWJ = sgeo[sid * p_Nsgeo + p_WSJID];
	  const dfloat n1 = sgeo[sid * p_Nsgeo + p_NXID] * sWJ;
	  const dfloat n2 = sgeo[sid * p_Nsgeo + p_NYID] * sWJ;
	  const dfloat n3 = sgeo[sid * p_Nsgeo + p_NZID] * sWJ;
	  
	  const dfloat s11 = sij[idM + 0 * offset];
	  const dfloat s21 = sij[idM + 3 * offset];
	  const dfloat s31 = sij[idM + 5 * offset];
	  
	  const dfloat s12 = sij[idM + 3 * offset];
	  const dfloat s22 = sij[idM + 1 * offset];
	  const dfloat s32 = sij[idM + 4 * offset];
	  
	  const dfloat s13 = sij[idM + 5 * offset];
	  const dfloat s23 = sij[idM + 4 * offset];
	  const dfloat s33 = sij[idM + 2 * offset];
	  
	  const dfloat scale = mue * invLMM[idM];
	  
	  const dfloat dragx = -scale * (s11*n1 + s12*n2 + s13*n3);
	  const dfloat dragy = -scale * (s21*n1 + s22*n2 + s23*n3);
	  const dfloat dragz = -scale * (s31*n1 + s32*n2 + s33*n3);
	  
	  s_drag = sqrt(dragx * dragx + dragy * dragy + dragz * dragz);
	  s_area = sWJ;
	}
      }
      @barrier();
      
      for (int m = 0; m < p_Nfp; ++m; @inner(0)){
	if(biDM == biD){
	  drag[e] += s_drag;
	  area[e] += s_area;
	}
      }
      @barrier();
    }
  }
}
