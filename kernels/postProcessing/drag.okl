
@kernel void drag(const dlong Nelements,
		  const dlong offset,
		  const dlong nbiD,
		  const dfloat mue,
		  const dlong *biD,
		  @ restrict const dfloat *sgeo,
		  @ restrict const dlong *vmapM,
		  @ restrict const int *EToBM,
		  @ restrict const dfloat *invLMM,
		  @ restrict const dfloat *sij,		  
		  @ restrict dfloat *drag)
{
  for (dlong e=0; e < Nelements; e++; @outer(0)){

    @shared volatile dfloat s_drag[p_blockSize];
    
    for (int f = 0; f < p_Nfaces; f++) {
      const dlong biDM = EToBM[f + p_Nfaces * e];
      dlong ibiD = -1;
      for (int i = 0; i < nbiD; i++)
	if(biDM == biD[i])ibiD = i;
      
      if(ibiD >= 0){
	for (int t = 0; t < p_blockSize; ++t; @inner(0)){
	  if(t >= p_Nfp){
	    s_drag[t] = 0.0;
	  }
	  else{
	    const int n = t + f * p_Nfp;
	    const dlong sid = e * p_Nfaces * p_Nfp + n;
	    
	    const dlong idM = vmapM[sid];
	    const dfloat sWJ = sgeo[sid * p_Nsgeo + p_WSJID];
	    const dfloat n1 = sgeo[sid * p_Nsgeo + p_NXID] * sWJ;
	    const dfloat n2 = sgeo[sid * p_Nsgeo + p_NYID] * sWJ;
	    const dfloat n3 = sgeo[sid * p_Nsgeo + p_NZID] * sWJ;
	    
	    const dfloat s11 = sij[idM + 0 * offset];
	    const dfloat s21 = sij[idM + 3 * offset];
	    const dfloat s31 = sij[idM + 5 * offset];
	    
	    const dfloat s12 = sij[idM + 3 * offset];
	    const dfloat s22 = sij[idM + 1 * offset];
	    const dfloat s32 = sij[idM + 4 * offset];
	    
	    const dfloat s13 = sij[idM + 5 * offset];
	    const dfloat s23 = sij[idM + 4 * offset];
	    const dfloat s33 = sij[idM + 2 * offset];
	    
	    const dfloat scale = mue * invLMM[idM];
	    
	    const dfloat dragx = -scale * (s11*n1 + s12*n2 + s13*n3);
	    const dfloat dragy = -scale * (s21*n1 + s22*n2 + s23*n3);
	    const dfloat dragz = -scale * (s31*n1 + s32*n2 + s33*n3);
	    
	    s_drag[t] = sqrt(dragx * dragx + dragy * dragy + dragz * dragz);
	  }
	}
	@barrier();
		
#if p_blockSize > 512
	for (int t = 0; t < p_blockSize; ++t; @inner(0))
	  if (t < 512) {
	    s_drag[t] += s_drag[t + 512];
	  }
	@barrier();
#endif
#if p_blockSize > 256
	for (int t = 0; t < p_blockSize; ++t; @inner(0))
	  if (t < 256) {
	    s_drag[t] += s_drag[t + 256];
	  }
	@barrier();
#endif
	
	for (int t = 0; t < p_blockSize; ++t; @inner(0))
	  if (t < 128) {
	    s_drag[t] += s_drag[t + 128];
	  }
	@barrier();
	
	for (int t = 0; t < p_blockSize; ++t; @inner(0))
	  if (t < 64) {
	    s_drag[t] += s_drag[t + 64];
	  }
	@barrier();
	
	for (int t = 0; t < p_blockSize; ++t; @inner(0))
	  if (t < 32) {
	    s_drag[t] += s_drag[t + 32];
	  }
	@barrier();
	for (int t = 0; t < p_blockSize; ++t; @inner(0))
	  if (t < 16) {
	    s_drag[t] += s_drag[t + 16];
	  }
	@barrier();
	for (int t = 0; t < p_blockSize; ++t; @inner(0))
	  if (t < 8) {
	    s_drag[t] += s_drag[t + 8];
	  }
	@barrier();
	for (int t = 0; t < p_blockSize; ++t; @inner(0))
	  if (t < 4) {
	    s_drag[t] += s_drag[t + 4];
	  }
	@barrier();
	for (int t = 0; t < p_blockSize; ++t; @inner(0))
	  if (t < 2) {
	    s_drag[t] += s_drag[t + 2];
	  }
	@barrier();
	for (int t = 0; t < p_blockSize; ++t; @inner(0))
	  if (t < 1) {
	    drag[e + Nelements * ibiD] = s_drag[0] + s_drag[1];
	  }
      }
    }
  }
}
