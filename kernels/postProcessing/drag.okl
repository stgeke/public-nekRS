
@kernel void drag(const dlong Nelements,
		  const dlong offset,
		  const dlong soffset,
		  const dlong nbiD,
		  const dfloat mue,
		  const dlong biD,
		  @ restrict const dfloat *sgeo,
		  @ restrict const dlong *vmapM,
		  @ restrict const int *EToBM,
		  @ restrict const dfloat *invLMM,
		  @ restrict const dfloat *sij,		  
		  @ restrict dfloat *drag,
		  @ restrict dfloat *area)
{
  for (dlong b=0; b < (Nelements + p_blockSize - 1) / p_blockSize; ++b; @outer(0)){

    @shared volatile dfloat s_drag1[p_blockSize];
    @shared volatile dfloat s_area1[p_blockSize];

    const dlong Nblock = (Nelements + p_blockSize - 1)/p_blockSize;
    
    for (int t = 0; t < p_blockSize; ++t; @inner(0)){
      s_drag1[t] = 0;
      s_area1[t] = 0;
      dfloat s_drag[p_Nfp];
      dfloat s_area[p_Nfp];
      const dlong e = t + p_blockSize * b;
      if(e < Nelements){
	for (int f = 0; f < p_Nfaces; f++) {
	  const dlong biDM = EToBM[f + p_Nfaces * e];
	  for (int m = 0; m < p_Nfp; ++m){
	    s_drag[m] = 0.0;
	    s_area[m] = 0.0;
	    if(biDM == biD){
	      const int n = m + f * p_Nfp;
	      const dlong sid = e * p_Nfaces * p_Nfp + n;
	      
	      const dlong idM = vmapM[sid];
	      const dfloat sWJ = sgeo[sid * p_Nsgeo + p_WSJID];
	      const dfloat n1 = sgeo[sid * p_Nsgeo + p_NXID] * sWJ;
	      const dfloat n2 = sgeo[sid * p_Nsgeo + p_NYID] * sWJ;
	      const dfloat n3 = sgeo[sid * p_Nsgeo + p_NZID] * sWJ;
	      
	      const dfloat s11 = sij[idM + 0 * offset];
	      const dfloat s21 = sij[idM + 3 * offset];
	      const dfloat s31 = sij[idM + 5 * offset];
	      
	      const dfloat s12 = sij[idM + 3 * offset];
	      const dfloat s22 = sij[idM + 1 * offset];
	      const dfloat s32 = sij[idM + 4 * offset];
	      
	      const dfloat s13 = sij[idM + 5 * offset];
	      const dfloat s23 = sij[idM + 4 * offset];
	      const dfloat s33 = sij[idM + 2 * offset];
	    
	      const dfloat scale = mue * invLMM[idM];
	      
	      const dfloat dragx = -scale * (s11*n1 + s12*n2 + s13*n3);
	      const dfloat dragy = -scale * (s21*n1 + s22*n2 + s23*n3);
	      const dfloat dragz = -scale * (s31*n1 + s32*n2 + s33*n3);
	      
	      s_drag[m] = sqrt(dragx * dragx + dragy * dragy + dragz * dragz);
	      s_area[m] = sWJ;
	    }
	  }
	  @barrier();
	  for (int m = 0; m < p_Nfp; ++m){
	    if(biDM == biD){
	      s_drag1[t] += s_drag[m];
	      s_area1[t] += s_area[m];
	    }
	  }
	  @barrier();
	}
      }
      else
	{
	  s_drag1[t] = 0;
	  s_area1[t] = 0;
	}
    }
    @barrier();
    //Thread Reduction
#if p_blockSize > 512
    for (int t = 0; t < p_blockSize; ++t; @inner(0))
      if (t < 512) {
        s_drag1[t] += s_drag1[t + 512];
        s_area1[t] += s_area1[t + 512];
      }
    @barrier();
#endif
#if p_blockSize > 256
    for (int t = 0; t < p_blockSize; ++t; @inner(0))
      if (t < 256) {
        s_drag1[t] += s_drag1[t + 256];
        s_area1[t] += s_area1[t + 256];
      }
    @barrier();
#endif

    for (int t = 0; t < p_blockSize; ++t; @inner(0))
      if (t < 128) {
        s_drag1[t] += s_drag1[t + 128];
        s_area1[t] += s_area1[t + 128];
      }
    @barrier();

    for (int t = 0; t < p_blockSize; ++t; @inner(0))
      if (t < 64) {
        s_drag1[t] += s_drag1[t + 64];
        s_area1[t] += s_area1[t + 64];
      }
    @barrier();

    for (int t = 0; t < p_blockSize; ++t; @inner(0))
      if (t < 32) {
        s_drag1[t] += s_drag1[t + 32];
        s_area1[t] += s_area1[t + 32];
      }
    @barrier();
    for (int t = 0; t < p_blockSize; ++t; @inner(0))
      if (t < 16) {
        s_drag1[t] += s_drag1[t + 16];
        s_area1[t] += s_area1[t + 16];
      }
    @barrier();
    for (int t = 0; t < p_blockSize; ++t; @inner(0))
      if (t < 8) {
        s_drag1[t] += s_drag1[t + 8];
        s_area1[t] += s_area1[t + 8];
      }
    @barrier();
    for (int t = 0; t < p_blockSize; ++t; @inner(0))
      if (t < 4) {
        s_drag1[t] += s_drag1[t + 4];
        s_area1[t] += s_area1[t + 4];
      }
    @barrier();
    for (int t = 0; t < p_blockSize; ++t; @inner(0))
      if (t < 2) {
        s_drag1[t] += s_drag1[t + 2];
        s_area1[t] += s_area1[t + 2];
      }
    @barrier();
    for (int t = 0; t < p_blockSize; ++t; @inner(0))
      if (t < 1) {
        drag[b] = s_drag1[0] + s_drag1[1];
        area[b] = s_area1[0] + s_area1[1];
      }
  }
}
